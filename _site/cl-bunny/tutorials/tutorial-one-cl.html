<!DOCTYPE html>
<html>
  <head> 
  	<title>title</title>
    <meta charset='utf-8'>
    
    <meta name="description" content="">
  	<meta name="keywords" content="">

    <link rel="stylesheet" type="text/css" href="style/style.css">

    <script src="js/jquery.js"></script>
    <script src="js/script.js"></script>


<!--[if lt IE 10]>
<script src="https://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->

<!--[if lt IE 9]>
<script src="js/respond.js"></script>
<link rel="stylesheet" type="text/css" href="style/ie8.css">
<![endif]-->

  </head>
  <body>    

    <header>
      <div class="width">
        <nav>
          <!-- <a href="/documentation">Documentation</a>
          <a href="/tutorials">Tutorials</a>
          <a href="https://github.com/cl-rabbit/cl-bunny">GitHub</a> -->
          <a href="/cl-rabbit">cl-rabbit</a>
          <a href="/cl-bunny">cl-bunny</a>
          <a href="/cl-amqp">cl-amqp</a>
          <a href="https://github.com/cl-rabbit/" class="github-link">GitHub</a>
        </nav>
      </div>
    </header>

    <section cless="content">


<!--
Copyright (C) 2007-2015 Pivotal Software, Inc. 

All rights reserved. This program and the accompanying materials
are made available under the terms of the under the Apache License, 
Version 2.0 (the "License”); you may not use this file except in compliance 
with the License. You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<h1 id="rabbitmq-tutorial---hello-world">RabbitMQ tutorial - “Hello World!”</h1>

<h2 id="introduction">Introduction</h2>

<p>RabbitMQ is a message broker. In essence, it accepts messages from
<em>producers</em>, and delivers them to <em>consumers</em>. In-between, it can
route, buffer, and persist the messages according to rules you give
it.</p>

<p>RabbitMQ, and messaging in general, uses some jargon.</p>

<ul>
  <li>
    <p><em>Producing</em> means nothing more than sending. A program that sends messages
is a <em>producer</em>. We’ll draw it like that, with “P”:<br />
<img src="http://i.imgur.com/mPTaxSl.png" alt="P" /></p>
  </li>
  <li>
    <p><em>A queue</em> is the name for a mailbox. It lives inside
RabbitMQ. Although messages flow through RabbitMQ and your
applications, they can be stored only inside a <em>queue</em>. A <em>queue</em>
is not bound by any limits, it can store as many messages as you
like - it’s essentially an infinite buffer. Many <em>producers</em> can send
messages that go to one queue - many <em>consumers</em> can try to
receive data from one <em>queue</em>. A queue will be drawn like this, with
its name above it:<br />
<img src="http://i.imgur.com/6dDlW1g.png" alt="{||||}" /></p>
  </li>
  <li>
    <p><em>Consuming</em> has a similar meaning to receiving. A <em>consumer</em> is a program
that mostly waits to receive messages. On our drawings it’s shown with “C”:<br />
<img src="http://i.imgur.com/U9mJa0I.png" alt="C" /></p>
  </li>
</ul>

<p>Note that the producer, consumer, and  broker do not have to reside on
the same machine; indeed in most applications they don’t.</p>

<h2 id="hello-world">“Hello World”</h2>
<p>### (using the cl-bunny Common Lisp Client)</p>

<p>In this part of the tutorial we’ll write two small programs in Lisp; a
producer that sends a single message, and a consumer that receives
messages and prints them out.  We’ll gloss over some of the detail in
the <a href="http://cl-rabbit.io/cl-bunny">cl-bunny</a> API, concentrating on this very simple thing just to get
started. It’s a “Hello World” of messaging.</p>

<p>In the diagram below, “P” is our producer and “C” is our consumer. The
box in the middle is a queue - a message buffer that RabbitMQ keeps
on behalf of the consumer.<br />
<img src="http://i.imgur.com/VjRoMDS.png" alt="(P) -&gt; [|||] -&gt; (C)" /></p>

<blockquote>
  <h4 id="the-cl-bunny-client-library">The cl-bunny client library</h4>

  <p>RabbitMQ speaks AMQP 0.9.1, which is an open,
general-purpose protocol for messaging. There are a number of clients
for RabbitMQ in <a href="/devtools.html">many different
languages</a>. We’ll
use the cl-bunny client in this tutorial.</p>

  <p>First, install cl-bunny using <a href="http://cl-rabbit.io/cl-bunny">official webpage</a></p>

</blockquote>

<p>Now we have cl-bunny installed, we can write some
code.</p>

<h3 id="sending">Sending</h3>
<p><img src="http://i.imgur.com/ph26szM.png" alt="(P) -&gt; [|||]" /></p>

<p>We’ll call our message sender <code>send.lisp</code> and our message receiver
<code>receive.lisp</code>.  The sender will connect to RabbitMQ, send a single message,
then exit.</p>

<p>In
<a href="code/send.lisp"><code>send.lisp</code></a>,
we need to require the library first:</p>

<pre><code>:::lisp

(ql:quickload 'cl-bunny)
</code></pre>

<p>then connect to RabbitMQ server</p>

<pre><code>:::lisp
(with-connection ("amqp://")
  ...
)
</code></pre>

<p>The connection abstracts the socket connection, and takes care of
protocol version negotiation and authentication and so on for us. Here
we connect to a broker on the local machine with all default settings.</p>

<p>If we wanted to connect to a broker on a different
machine we’d simply specify its name or IP address using the <code>:hostname</code>
option:</p>

<pre><code>:::lisp
(with-connection ("amqp://rabbit.local")
  ...
)
</code></pre>

<p>Next we create a channel, which is where most of the API for getting
things done resides:</p>

<pre><code>:::lisp
(with-channel ()
  ...
)
</code></pre>

<p>To send, we must declare a queue for us to send to; then we can publish a message
to the queue:</p>

<pre><code>:::lisp
(with-connection ("amqp://")
  (with-channel ()
    (let ((x (default-exchange)))
      (publish x "Hello world!" :routing-key "hello")          
      (format t " [x] Sent 'Hello World!'~%"))))
</code></pre>

<p>Declaring a queue is idempotent - it will only be created if it doesn’t
exist already. The message content is a byte array, so you can encode
whatever you like there.</p>

<p>Lastly, we close the connection;</p>

<p>Thanks to <code>with-connection</code> we don’t have to close connection. It does this automatically</p>

<p><a href="code/send.lisp">Here’s the whole send.lisp script</a>.</p>

<blockquote>
  <h4 id="sending-doesnt-work">Sending doesn’t work!</h4>

  <p>If this is your first time using RabbitMQ and you don’t see the “Sent”
message then you may be left scratching your head wondering what could
be wrong. Maybe the broker was started without enough free disk space
(by default it needs at least 1Gb free) and is therefore refusing to
accept messages. Check the broker logfile to confirm and reduce the
limit if necessary. The <a href="http://www.rabbitmq.com/configure.html#config-items">configuration
file documentation</a> will show you how to set <code>disk_free_limit</code>.</p>
</blockquote>

<h3 id="receiving">Receiving</h3>

<p>That’s it for our sender.  Our receiver is pushed messages from
RabbitMQ, so unlike the sender which publishes a single message, we’ll
keep it running to listen for messages and print them out.<br />
<img src="http://i.imgur.com/3teOytn.png" alt="[|||] -&gt; (C)" /></p>

<p>The code (in <a href="code/receive.lisp"><code>receive.lisp</code></a>) has the same require as <code>send.lisp</code>:</p>

<pre><code>:::lisp
(ql:quickload 'cl-bunny)
</code></pre>

<p>Setting up is the same as the sender; we open a connection and a
channel, and declare the queue from which we’re going to consume.
Note this matches up with the queue that <code>send</code> publishes to.</p>

<pre><code>:::lisp
(with-connection ("amqp://")
  (with-channel ()
    (let ((x (default-exchange)))          
      (format t " [*] Waiting for messages in queue 'hello'. To exit type (exit)~%")
      (queue.declare "hello" :auto-delete t)
      ...
))
</code></pre>

<p>Note that we declare the queue here, as well. Because we might start
the receiver before the sender, we want to make sure the queue exists
before we try to consume messages from it.</p>

<p>We’re about to tell the server to deliver us the messages from the
queue. Since it will push us messages asynchronously, we provide a
callback that will be executed when RabbitMQ pushes messages to
our consumer. This is what <code>subscribe</code> does.</p>

<pre><code>:::lisp
(with-connection ("amqp://")
  (with-channel ()
    (let ((q (queue.declare "hello" :auto-delete t)))
      (format t " [*] Waiting for messages in queue 'hello'. To exit type (exit)~%")
      (subscribe q (lambda (message)
                     (let ((body (babel:octets-to-string (message-body message))))
                       (format t " [x] Received ~a~%" body)))
                 :type :sync)
      (consume :one-shot t))))
</code></pre>

<p><code>subscribe</code> is used with the <code>:type :sync</code> option that makes it
block the calling thread (we don’t want the script to finish running immediately!).</p>

<p><a href="code/receive.lisp">Here’s the whole receive.lisp script</a>.</p>

<h3 id="putting-it-all-together">Putting it all together</h3>

<p>Now we can run both scripts. In a terminal, run the sender:</p>

<pre><code>:::bash
$ sbcl --non-interactive --load send.lisp
</code></pre>

<p>then, run the receiver:</p>

<pre><code>:::bash
$ sbcl --non-interactive --load receive.lisp
</code></pre>

<p>The receiver will print the message it gets from the sender via
RabbitMQ. The receiver will keep running, waiting for messages (Use function <code>cl-user::exit</code> to stop it), so try running
the sender from another terminal.</p>

<p>If you want to check on the queue, try using <code>rabbitmqctl list_queues</code>.</p>

<p>Hello World!</p>

<p>Time to move on to <a href="tutorial-two-cl.md">part 2</a> and build a simple <em>work queue</em>.</p>


    </section>
    <footer>
      <div class="width">
        <div class="copyright">
          Copyright
        </div>
      </div>
    </footer>

  </body>
</html>